# Copyright Allo authors. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
"""
Example extensible backend template.

This file demonstrates how to create a custom backend for Allo.
To use this backend, call: s.build(target="byoc")

To create your own backend:
1. Copy this file and rename it (e.g., myxcel.py)
2. Implement the `build` function with your custom logic
3. Optionally create a custom Module class to wrap the result
4. Use it via: s.build(target="myxcel")
"""

from .._mlir.ir import Context, Module
from .._mlir.dialects import allo as allo_d
from ..ir.transform import find_func_in_module


class ExampleModule:
    """
    Example module class that wraps the compiled result.

    Your custom module class can provide methods like:
    - Code generation (e.g., to a specific hardware format)
    - Simulation/execution
    - Exporting to files
    - Hardware synthesis
    """

    def __init__(
        self,
        module,
        top_func_name,
        ext_libs=None,
        mode=None,
        project=None,
        configs=None,
        func_args=None,
        wrap_io=True,
    ):
        # Copy the module to avoid modifying the original
        with Context() as ctx:
            allo_d.register_dialect(ctx)
            self.module = Module.parse(str(module), ctx)
            self.top_func_name = top_func_name
            self.ext_libs = ext_libs or []
            self.mode = mode
            self.project = project or f"{top_func_name}.prj"
            self.configs = configs or {}
            self.func_args = func_args
            self.wrap_io = wrap_io

            # Find the top function
            self.func = find_func_in_module(self.module, top_func_name)

    def __repr__(self):
        return f"ExampleModule(top={self.top_func_name}, mode={self.mode})"

    def get_ir(self):
        """Return the MLIR representation as a string."""
        return str(self.module)

    def codegen(self, output_dir=None):
        """
        Generate code for your target platform.

        This is where you would implement:
        - MLIR lowering passes specific to your backend
        - Code generation to your target language/format
        - File output
        """
        # Example: just return the IR for now
        code = f"// Generated by ExampleModule for {self.top_func_name}\n"
        code += f"// Mode: {self.mode}\n"
        code += f"// Project: {self.project}\n\n"
        code += str(self.module)
        return code

    def __call__(self, *args, **kwargs):
        """
        Execute/simulate the module.

        Implement this if your backend supports execution.
        """
        raise NotImplementedError(
            "ExampleModule.run() is not implemented. "
            "Override this method in your custom backend."
        )


def build(
    module,
    top_func_name,
    ext_libs,
    mode,
    project,
    configs,
    func_args,
    wrap_io,
):
    """
    Build function called by Schedule.build(target="example").

    This is the entry point for your custom backend. It receives:

    Parameters
    ----------
    module : _mlir.ir.Module
        The MLIR module containing the compiled Allo program.
    top_func_name : str
        The name of the top-level function.
    ext_libs : list
        List of external libraries to link.
    mode : str or None
        Build mode (e.g., "csim", "csyn", "sw_emu", "hw_emu", "hw").
    project : str or None
        Project directory name.
    configs : dict or None
        Additional configuration options.
    func_args : dict or None
        Function argument information.
    wrap_io : bool
        Whether to wrap I/O interfaces.

    Returns
    -------
    ExampleModule
        A module object that wraps the compiled result.
    """
    return ExampleModule(
        module=module,
        top_func_name=top_func_name,
        ext_libs=ext_libs,
        mode=mode,
        project=project,
        configs=configs,
        func_args=func_args,
        wrap_io=wrap_io,
    )

